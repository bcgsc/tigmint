#!/usr/bin/env python3 
"""
Cuts long reads and assign barcodes to the subreads and optionally calculates tigmint-long span and dist parameters.
Usage: gunzip -c reads.fa.gz (or reads.fq.gz) | python3 long-to-linked -l length -m min_size -s -g genome_size | gzip > reads.cutlength.fa.gz
@author: Janet Li
"""

import sys
import os
import argparse
import numpy as np
from read_fasta import read_fasta

def split_long_read(read_string, length):
    """Take an input read string and length, and cut the read into sub-reads of the specified length."""
    return [read_string.strip()[0+i:length+i] for i in range(0, len(read_string), length)]

def cut_reads(length, min_size, auto_span, genome_size, param_outfile, auto_dist):
    """
    Print cut reads to stdout. If auto_span is True, sequence coverage and span parameter are calculated,
    and span is saved to file. If auto_dist is True, read length p5 is calculated and saved to file.
    """
    # Span automatically calculated as 1/4 of sequence coverage
    cov_to_span = 0.25
    # Dist automatically calculated as p5 of read length
    dist_read_perc = 5
    # Lower bound for dist
    dist_lower_bound = 1000

    total_bases = 0
    if auto_dist:
        read_lengths = []
    with open("/dev/stdin", 'rt') as reads:
        barcode = 0
        if not reads.isatty():  # Check that reads are being piped in from stdin
            for header, seq, _, qual in read_fasta(reads):
                read_length = len(seq)
                total_bases += read_length
                if auto_dist and read_length >= dist_lower_bound:
                    read_lengths.append(read_length)
                if read_length >= min_size:
                    split_reads = split_long_read(seq, length)
                    if qual:
                        split_quals = split_long_read(qual, length)
                    else:
                        split_quals = split_long_read(read_length * "#", length)
                    for i, read in enumerate(split_reads):
                        outheader = "@{0}_{1} BX:Z:{2}".format(header, str(i), str(barcode))
                        print(outheader, read, "+", split_quals[i], sep="\n", file=sys.stdout)
                    barcode += 1
            if auto_span or auto_dist:
                with open(param_outfile, "w") as param_file:
                    if auto_span:
                        span = int(total_bases / genome_size * cov_to_span)
                        print("span\t%s" % str(span), file=param_file)
                    if auto_dist:
                        dist = int(np.percentile(read_lengths, dist_read_perc))
                        print("read_p%i\t%i" % (dist_read_perc, dist), file=param_file)
        else:
            print("long-to-linked: error: long reads must be piped from stdin", file=sys.stderr)
            sys.exit(1)

def get_genome_size(size_string):
    """Read genome size from a string."""
    try:
        return float(size_string)
    except ValueError:
        print("long-to-linked: error: improper format for genome size", file=sys.stderr)
        sys.exit(1)

def main():
    """Parse arguments and cut long reads."""
    parser = argparse.ArgumentParser(description="Segment long reads into short reads and calculate tigmint-long parameters.")
    parser.add_argument("-v", "--version",
                        action="version",
                        version="long-to-linked 1.3.0")
    parser.add_argument("-l", "--length",
                        type=int,
                        default=500,
                        help="Length for long reads to be cut to")
    parser.add_argument("-m", "--min_size",
                        type=int,
                        default=2000,
                        help="Minimum read length to be considered a molecule")
    parser.add_argument("-s", "--auto_span",
                        default=False,
                        action="store_true",
                        help="Option to calculate spanning molecules threshold")
    parser.add_argument("-d", "--auto_dist",
                        default=False,
                        action="store_true",
                        help="Option to calculate read length p5 for dist parameter")
    parser.add_argument("-g", "--genome_size",
                        type=str,
                        help="Genome size for calculating sequence coverage and \
                        minimum spanning molecules parameter (e.g. 3e9)")
    parser.add_argument("-o", "--param_outfile",
                        type=str,
                        default="tigmint-long.params.tsv",
                        help="Output file for calculated span")

    args = parser.parse_args()

    if args.auto_span:
        args.genome_size = get_genome_size(args.genome_size)

    cut_reads(args.length, args.min_size, args.auto_span,
            args.genome_size, args.param_outfile, args.auto_dist)
   
if __name__ == "__main__":
    main()
