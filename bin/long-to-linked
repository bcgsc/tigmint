#!/usr/bin/env python3 
"""
Cut long reads and assign barcodes to the subreads. Optionally calculate span parameter for tigmint-cut.
Usage: gunzip -c reads.fa.gz (or reads.fq.gz) | python3 long-to-linked -l length -m min_size -s auto_span -g genome_size | gzip > reads.cutlength.fa.gz
@author: Janet Li
"""
import sys
import os
import argparse
from read_fasta import read_fasta

def split_long_read(read_string, length):
    """Take an input read string and length, and cut the read into sub-reads of the specified length."""
    return [read_string.strip()[0+i:length+i] for i in range(0, len(read_string), length)]

<<<<<<< HEAD
def cut_reads(length, long_reads, min_size):
    """Print cut reads to stdout."""
    file_name = "/dev/stdin" if long_reads == "-" else long_reads
    with open(file_name, 'rt') as reads:
        i = 0
        for header, seq, _, _ in read_fasta(reads):
            i += 1
            if len(seq) >= min_size:
                split_reads = split_long_read(seq, length)
                for i, read in enumerate(split_reads):
                    print(">" + header + "_" + str(split_reads.index(read)) + " BX:Z:" + str(i), file=sys.stdout)
                    print(read, file=sys.stdout)

def main():
    """Parse arguments and cut long reads."""
    parser = argparse.ArgumentParser(description="Split long reads into pseudo-linked reads with a length of l.")
    parser.add_argument("-l", "--length", metavar="cut length for long reads",
        dest="cut_length", default=500, type=int, 
        help="Length for pseudo-linked reads to be cut (bp)")
    parser.add_argument("-r", "--reads", metavar="input long read file", 
        dest="long_reads", required=True, help="Long read file")
    parser.add_argument("-m", "--min_size", metavar="minimum read size", dest="min_size", 
        default=2000, type=int, help="Minimum read length to be considered a molecule (bp)")

    arguments = parser.parse_args()
    l = arguments.cut_length
    ont = arguments.long_reads
    min_size = arguments.min_size

    cut_reads(l, ont, min_size)
=======
def cut_reads(length, min_size, auto_span, genome_size, outfile):
    """
    Print cut reads to stdout. If auto_span is True, sequence coverage and span parameter are calculated,
    and span is saved to tigmint-long.span.txt.
    """
    # Span automatically calculated as 1/4 of sequence coverage
    cov_to_span = 0.25
    total_bases = 0

    with open("/dev/stdin", 'rt') as reads:
        if not reads.isatty():  # Check that reads are being piped in from stdin
            i = 0
            for header, seq, _, _ in read_fasta(reads):
                i += 1
                read_length = len(seq)
                total_bases += read_length
                if read_length >= min_size:
                    split_reads = split_long_read(seq, length)
                    for read in split_reads:
                        print(">" + header + "_" + str(split_reads.index(read)) + " BX:Z:" + str(i), file=sys.stdout)
                        print(read, file=sys.stdout)
            if auto_span:
                genome_size = int(genome_size)
                with open(outfile, "w") as span_file:
                    span = int(total_bases / genome_size * cov_to_span)
                    span_file.write(str(span))

        else:
            print("long-to-linked: error: long reads must be piped from stdin", file=sys.stderr)
            sys.exit(1)

def calculate_span(param_value):
    """Allowed values for -s argument (option to calculate span)."""
    if param_value.isnumeric():
        return False
    elif param_value == "auto":
        return True
    else:
        raise argparse.ArgumentTypeError("Span must be set to 'auto' to be calculated automatically.")

def main():
    """Parse arguments and cut long reads."""
    parser = argparse.ArgumentParser(description="Segment long reads into short reads and calculate span.")
    parser.add_argument("-l", "--length",
                        type=int,
                        default=500,
                        help="Length for long reads to be cut to")
    parser.add_argument("-m", "--min_size",
                        type=int,
                        default=2000,
                        help="Minimum read length to be considered a molecule")
    parser.add_argument("-s", "--auto_span",
                        type=calculate_span,
                        default=True,
                        help="Option to calculate spanning molecules threshold")
    parser.add_argument("-g", "--genome_size",
                        type=str,
                        default="gsize",
                        help="Genome size (bp) for calculating sequence coverage and \
                        minimum spanning molecules parameter automatically")
    parser.add_argument("-o", "--outfile",
                        type=str,
                        default="tigmint-long.span.txt",
                        help="Output file for calculated span")

    args = parser.parse_args()

    if args.auto_span:
        if not args.genome_size.isnumeric():
            raise argparse.ArgumentTypeError("Genome size (bp) must be provided to calculate span parameter.")

    cut_reads(args.length, args.min_size, args.auto_span, args.genome_size, args.outfile)
>>>>>>> Calculate span in long-to-linked
   
if __name__ == "__main__":
    main()
